struct Light {
  float4 position;
  float3 intensities;
  float ambientCoefficient;
};

static float materialShininess = 1.f;
static float3 materialSpecularColor = float3(0.59f, 0.59f, 0.59f);

static Light light = Light
(
 float4(-30.f, 75.f, 0.0f, 0.f),
 float3(1.f, 1.f, 1.f),
 0.8f
);

struct VertexOut
{
  float4 outPosition : POSITION;
  float3 vPosition : TEXCOORD0;
  float3 vNormal: TEXCOORD1;
  float2 vTexCoord: TEXCOORD2;
};

float3 applyLight(Light light,
		  float3 surfaceColor,
		  float3 normal,
		  float3 surfacePos,
		  float3 surfaceToCamera)
{
  float3 surfaceToLight;
  float attenuation = 1.f;

  surfaceToLight = normalize(light.position.xyz);
  attenuation = 1.f;

  // Ambient
  float3 ambient = light.ambientCoefficient * surfaceColor.rgb * light.intensities;

  // Diffuse
  float diffuseCoefficient = max(0.f, dot(normal, surfaceToLight));
  float3 diffuse = diffuseCoefficient * surfaceColor.rgb * light.intensities;

  // Specular
  float specularCoefficient = 0.f;
  if (diffuseCoefficient > 0.f)
    specularCoefficient = pow(max(0.f, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);
  float3 specular = specularCoefficient * materialSpecularColor * light.intensities;

  //linear color (color before gamma correction)
  return ambient + attenuation*(diffuse + specular);
}

float4 main(
       uniform sampler2D tex,
       uniform float4x4 model,
       uniform float3 cameraPosition,
       VertexOut vOut
       ) : COLOR
{
  float3 surfacePos = float3(mul(model, float4(vOut.vPosition, 1))).xyz;
  float4 surfaceColor = tex2D(tex, vOut.vTexCoord);
  float3 surfaceToCamera = normalize(cameraPosition - surfacePos);

  float3 linearColor = float3(0.f);

  linearColor += applyLight(light, surfaceColor.rgb, vOut.vNormal, surfacePos, surfaceToCamera);
  
  return float4(linearColor, 1.f);
}
